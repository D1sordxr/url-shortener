// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: urls.sql

package gen

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const createURL = `-- name: CreateURL :one
INSERT INTO urls (
    alias,
    url
) VALUES (
    $1, $2
)
RETURNING id, alias, url, created_at, updated_at
`

type CreateURLParams struct {
	Alias string `json:"alias"`
	Url   string `json:"url"`
}

// Запрос создает url
// Возвращает созданную запись целиком
func (q *Queries) CreateURL(ctx context.Context, arg CreateURLParams) (Url, error) {
	row := q.db.QueryRowContext(ctx, createURL, arg.Alias, arg.Url)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.Alias,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createURLStat = `-- name: CreateURLStat :one
INSERT INTO url_stats (
    url_id,
    user_id,
    user_agent,
    ip_address,
    referer
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, url_id, user_id, user_agent, ip_address, referer, created_at
`

type CreateURLStatParams struct {
	UrlID     int32          `json:"url_id"`
	UserID    sql.NullString `json:"user_id"`
	UserAgent sql.NullString `json:"user_agent"`
	IpAddress pqtype.Inet    `json:"ip_address"`
	Referer   sql.NullString `json:"referer"`
}

// Создание записи статистики перехода
func (q *Queries) CreateURLStat(ctx context.Context, arg CreateURLStatParams) (UrlStat, error) {
	row := q.db.QueryRowContext(ctx, createURLStat,
		arg.UrlID,
		arg.UserID,
		arg.UserAgent,
		arg.IpAddress,
		arg.Referer,
	)
	var i UrlStat
	err := row.Scan(
		&i.ID,
		&i.UrlID,
		&i.UserID,
		&i.UserAgent,
		&i.IpAddress,
		&i.Referer,
		&i.CreatedAt,
	)
	return i, err
}

const getByAlias = `-- name: GetByAlias :one
SELECT id, alias, url, created_at, updated_at FROM urls
WHERE alias = $1
`

// Запрос получает url по alias
func (q *Queries) GetByAlias(ctx context.Context, alias string) (Url, error) {
	row := q.db.QueryRowContext(ctx, getByAlias, alias)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.Alias,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompleteAnalytics = `-- name: GetCompleteAnalytics :one
WITH stats AS (
    SELECT
        us.url_id,
        COUNT(*) as total_visits,
        COUNT(DISTINCT us.user_id) as unique_visitors,
        MIN(us.created_at) as first_visit,
        MAX(us.created_at) as last_visit
    FROM url_stats us
    GROUP BY us.url_id
),
     recent_visits AS (
         SELECT
             url_id,
             JSON_AGG(
                     JSON_BUILD_OBJECT(
                             'date', DATE(created_at),
                             'user_agent', user_agent,
                             'ip_address', ip_address,
                             'referer', referer,
                             'created_at', created_at
                     ) ORDER BY created_at DESC
             ) as raw_stats
         FROM url_stats
         WHERE url_id IN (SELECT id FROM urls WHERE alias = $1)
         GROUP BY url_id
     )
SELECT
    u.alias,
    u.url as original_url,
    COALESCE(s.total_visits, 0) as total_visits,
    COALESCE(s.unique_visitors, 0) as unique_visitors,
    s.first_visit,
    s.last_visit,
    COALESCE(rv.raw_stats, '[]'::json) as raw_stats
FROM urls u
         LEFT JOIN stats s ON u.id = s.url_id
         LEFT JOIN recent_visits rv ON u.id = rv.url_id
WHERE u.alias = $1
`

type GetCompleteAnalyticsRow struct {
	Alias          string          `json:"alias"`
	OriginalUrl    string          `json:"original_url"`
	TotalVisits    int64           `json:"total_visits"`
	UniqueVisitors int64           `json:"unique_visitors"`
	FirstVisit     interface{}     `json:"first_visit"`
	LastVisit      interface{}     `json:"last_visit"`
	RawStats       json.RawMessage `json:"raw_stats"`
}

func (q *Queries) GetCompleteAnalytics(ctx context.Context, alias string) (GetCompleteAnalyticsRow, error) {
	row := q.db.QueryRowContext(ctx, getCompleteAnalytics, alias)
	var i GetCompleteAnalyticsRow
	err := row.Scan(
		&i.Alias,
		&i.OriginalUrl,
		&i.TotalVisits,
		&i.UniqueVisitors,
		&i.FirstVisit,
		&i.LastVisit,
		&i.RawStats,
	)
	return i, err
}

const getPopularUserAgents = `-- name: GetPopularUserAgents :many
SELECT
    user_agent,
    COUNT(*) as count
FROM url_stats us
JOIN urls u ON us.url_id = u.id
WHERE u.alias = $1
GROUP BY user_agent
ORDER BY count DESC
LIMIT 10
`

type GetPopularUserAgentsRow struct {
	UserAgent sql.NullString `json:"user_agent"`
	Count     int64          `json:"count"`
}

// Самые популярные User-Agents
func (q *Queries) GetPopularUserAgents(ctx context.Context, alias string) ([]GetPopularUserAgentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPopularUserAgents, alias)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPopularUserAgentsRow
	for rows.Next() {
		var i GetPopularUserAgentsRow
		if err := rows.Scan(&i.UserAgent, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalVisits = `-- name: GetTotalVisits :one
SELECT COUNT(*) as total_visits
FROM url_stats us
JOIN urls u ON us.url_id = u.id
WHERE u.alias = $1
`

// Общее количество переходов по короткой ссылке
func (q *Queries) GetTotalVisits(ctx context.Context, alias string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalVisits, alias)
	var total_visits int64
	err := row.Scan(&total_visits)
	return total_visits, err
}

const getURLByID = `-- name: GetURLByID :one
SELECT id, alias, url, created_at, updated_at FROM urls
WHERE id = $1
`

// Получение URL по ID
func (q *Queries) GetURLByID(ctx context.Context, id int32) (Url, error) {
	row := q.db.QueryRowContext(ctx, getURLByID, id)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.Alias,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUniqueVisitors = `-- name: GetUniqueVisitors :one
SELECT COUNT(DISTINCT user_id) as unique_visitors
FROM url_stats us
JOIN urls u ON us.url_id = u.id
WHERE u.alias = $1
`

// Количество уникальных посетителей
func (q *Queries) GetUniqueVisitors(ctx context.Context, alias string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUniqueVisitors, alias)
	var unique_visitors int64
	err := row.Scan(&unique_visitors)
	return unique_visitors, err
}

const getUrlStats = `-- name: GetUrlStats :many
SELECT
    us.id, us.url_id, us.user_id, us.user_agent, us.ip_address, us.referer, us.created_at,
    u.alias,
    u.url
FROM url_stats us
JOIN urls u ON us.url_id = u.id
WHERE u.alias = $1
ORDER BY us.created_at DESC
`

type GetUrlStatsRow struct {
	ID        int32          `json:"id"`
	UrlID     int32          `json:"url_id"`
	UserID    sql.NullString `json:"user_id"`
	UserAgent sql.NullString `json:"user_agent"`
	IpAddress pqtype.Inet    `json:"ip_address"`
	Referer   sql.NullString `json:"referer"`
	CreatedAt time.Time      `json:"created_at"`
	Alias     string         `json:"alias"`
	Url       string         `json:"url"`
}

// Получение статистики переходов по короткой ссылке
func (q *Queries) GetUrlStats(ctx context.Context, alias string) ([]GetUrlStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUrlStats, alias)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUrlStatsRow
	for rows.Next() {
		var i GetUrlStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.UrlID,
			&i.UserID,
			&i.UserAgent,
			&i.IpAddress,
			&i.Referer,
			&i.CreatedAt,
			&i.Alias,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUrlStatsAggregated = `-- name: GetUrlStatsAggregated :many
SELECT
    DATE(us.created_at) as date,
    us.user_agent,
    COUNT(*) as visit_count
FROM url_stats us
JOIN urls u ON us.url_id = u.id
WHERE u.alias = $1
AND us.created_at >= $2
AND us.created_at <= $3
GROUP BY DATE(us.created_at), us.user_agent
ORDER BY date DESC, visit_count DESC
`

type GetUrlStatsAggregatedParams struct {
	Alias       string    `json:"alias"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetUrlStatsAggregatedRow struct {
	Date       time.Time      `json:"date"`
	UserAgent  sql.NullString `json:"user_agent"`
	VisitCount int64          `json:"visit_count"`
}

// Агрегированная статистика по дням/месяцам и User-Agent
func (q *Queries) GetUrlStatsAggregated(ctx context.Context, arg GetUrlStatsAggregatedParams) ([]GetUrlStatsAggregatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getUrlStatsAggregated, arg.Alias, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUrlStatsAggregatedRow
	for rows.Next() {
		var i GetUrlStatsAggregatedRow
		if err := rows.Scan(&i.Date, &i.UserAgent, &i.VisitCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUrlStatsByTimeRange = `-- name: GetUrlStatsByTimeRange :many
SELECT
    us.id, us.url_id, us.user_id, us.user_agent, us.ip_address, us.referer, us.created_at,
    u.alias,
    u.url
FROM url_stats us
JOIN urls u ON us.url_id = u.id
WHERE u.alias = $1
AND us.created_at >= $2
AND us.created_at <= $3
ORDER BY us.created_at DESC
`

type GetUrlStatsByTimeRangeParams struct {
	Alias       string    `json:"alias"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetUrlStatsByTimeRangeRow struct {
	ID        int32          `json:"id"`
	UrlID     int32          `json:"url_id"`
	UserID    sql.NullString `json:"user_id"`
	UserAgent sql.NullString `json:"user_agent"`
	IpAddress pqtype.Inet    `json:"ip_address"`
	Referer   sql.NullString `json:"referer"`
	CreatedAt time.Time      `json:"created_at"`
	Alias     string         `json:"alias"`
	Url       string         `json:"url"`
}

// Статистика с фильтрацией по временному диапазону
func (q *Queries) GetUrlStatsByTimeRange(ctx context.Context, arg GetUrlStatsByTimeRangeParams) ([]GetUrlStatsByTimeRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getUrlStatsByTimeRange, arg.Alias, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUrlStatsByTimeRangeRow
	for rows.Next() {
		var i GetUrlStatsByTimeRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.UrlID,
			&i.UserID,
			&i.UserAgent,
			&i.IpAddress,
			&i.Referer,
			&i.CreatedAt,
			&i.Alias,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
