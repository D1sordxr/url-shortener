// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notifications.sql

package gen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const cancelNotification = `-- name: CancelNotification :one
UPDATE notifications
SET
    status = 'declined'  -- Меняем статус на отмененный
WHERE
    id = $1
    RETURNING id, subject, message, author_id, email_to, telegram_chat_id, sms_to, channel, status, attempts, scheduled_at, sent_at, created_at, updated_at
`

// Запрос выполняет "мягкое удаление" путем изменения статуса на 'declined'
// Мы никогда не удаляем данные полностью, только меняем их состояние
// Это обеспечивает аудит и историчность данных
func (q *Queries) CancelNotification(ctx context.Context, id uuid.UUID) (Notification, error) {
	row := q.db.QueryRowContext(ctx, cancelNotification, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Subject,
		&i.Message,
		&i.AuthorID,
		&i.EmailTo,
		&i.TelegramChatID,
		&i.SmsTo,
		&i.Channel,
		&i.Status,
		&i.Attempts,
		&i.ScheduledAt,
		&i.SentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (
    subject,           -- Тема уведомления
    message,           -- Текст сообщения
    author_id,         -- ID автора (может быть NULL)
    email_to,          -- Email получателя (для email канала)
    telegram_chat_id,  -- ID чата Telegram (для telegram канала)
    sms_to,            -- Телефон получателя
    channel,           -- Канал отправки: email, telegram, sms
    status,            -- Статус уведомления
    attempts,          -- Количество попыток отправки
    scheduled_at       -- Время планируемой отправки
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9, $10
)
    RETURNING id, subject, message, author_id, email_to, telegram_chat_id, sms_to, channel, status, attempts, scheduled_at, sent_at, created_at, updated_at
`

type CreateNotificationParams struct {
	Subject        string             `json:"subject"`
	Message        string             `json:"message"`
	AuthorID       sql.NullString     `json:"author_id"`
	EmailTo        sql.NullString     `json:"email_to"`
	TelegramChatID sql.NullInt64      `json:"telegram_chat_id"`
	SmsTo          sql.NullString     `json:"sms_to"`
	Channel        ChannelType        `json:"channel"`
	Status         NotificationStatus `json:"status"`
	Attempts       int16              `json:"attempts"`
	ScheduledAt    time.Time          `json:"scheduled_at"`
}

// Запрос создает новое уведомление в базе данных;
// Возвращает созданную запись целиком
func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, createNotification,
		arg.Subject,
		arg.Message,
		arg.AuthorID,
		arg.EmailTo,
		arg.TelegramChatID,
		arg.SmsTo,
		arg.Channel,
		arg.Status,
		arg.Attempts,
		arg.ScheduledAt,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Subject,
		&i.Message,
		&i.AuthorID,
		&i.EmailTo,
		&i.TelegramChatID,
		&i.SmsTo,
		&i.Channel,
		&i.Status,
		&i.Attempts,
		&i.ScheduledAt,
		&i.SentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, subject, message, author_id, email_to, telegram_chat_id, sms_to, channel, status, attempts, scheduled_at, sent_at, created_at, updated_at FROM notifications
WHERE id = $1
`

// Запрос получает одно уведомление по его UUID;
// Используется для проверки статуса или деталей уведомления
func (q *Queries) GetNotificationByID(ctx context.Context, id uuid.UUID) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotificationByID, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Subject,
		&i.Message,
		&i.AuthorID,
		&i.EmailTo,
		&i.TelegramChatID,
		&i.SmsTo,
		&i.Channel,
		&i.Status,
		&i.Attempts,
		&i.ScheduledAt,
		&i.SentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingNotificationsForUpdate = `-- name: GetPendingNotificationsForUpdate :many
SELECT id, subject, message, author_id, email_to, telegram_chat_id, sms_to, channel, status, attempts, scheduled_at, sent_at, created_at, updated_at FROM notifications
WHERE status = 'pending'
    AND scheduled_at <= NOW()  -- Только уведомления, время отправки которых наступило
ORDER BY scheduled_at ASC
FOR UPDATE SKIP LOCKED
LIMIT $1
`

// Блокирует строки для обновления в транзакции
func (q *Queries) GetPendingNotificationsForUpdate(ctx context.Context, limit int32) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getPendingNotificationsForUpdate, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Subject,
			&i.Message,
			&i.AuthorID,
			&i.EmailTo,
			&i.TelegramChatID,
			&i.SmsTo,
			&i.Channel,
			&i.Status,
			&i.Attempts,
			&i.ScheduledAt,
			&i.SentAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setNotificationStatusFailedMany = `-- name: SetNotificationStatusFailedMany :exec
UPDATE notifications
SET status = 'failed'
WHERE id = ANY($1::uuid[])
`

func (q *Queries) SetNotificationStatusFailedMany(ctx context.Context, ids []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setNotificationStatusFailedMany, pq.Array(ids))
	return err
}

const setNotificationStatusSentMany = `-- name: SetNotificationStatusSentMany :exec
UPDATE notifications
SET status = 'sent'
WHERE id = ANY($1::uuid[])
`

func (q *Queries) SetNotificationStatusSentMany(ctx context.Context, ids []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setNotificationStatusSentMany, pq.Array(ids))
	return err
}

const updateNotificationStatus = `-- name: UpdateNotificationStatus :one
UPDATE notifications
SET
    status = $2,    -- Новый статус: sent, failed, etc.
    attempts = $3,  -- Увеличиваем счетчик попыток
    sent_at = $4    -- Время фактической отправки (если успешно)
WHERE
    id = $1
    RETURNING id, subject, message, author_id, email_to, telegram_chat_id, sms_to, channel, status, attempts, scheduled_at, sent_at, created_at, updated_at
`

type UpdateNotificationStatusParams struct {
	ID       uuid.UUID          `json:"id"`
	Status   NotificationStatus `json:"status"`
	Attempts int16              `json:"attempts"`
	SentAt   sql.NullTime       `json:"sent_at"`
}

// Запрос обновляет статус, счетчик попыток и время отправки уведомления;
// Используется воркером после попытки отправки
func (q *Queries) UpdateNotificationStatus(ctx context.Context, arg UpdateNotificationStatusParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, updateNotificationStatus,
		arg.ID,
		arg.Status,
		arg.Attempts,
		arg.SentAt,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Subject,
		&i.Message,
		&i.AuthorID,
		&i.EmailTo,
		&i.TelegramChatID,
		&i.SmsTo,
		&i.Channel,
		&i.Status,
		&i.Attempts,
		&i.ScheduledAt,
		&i.SentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
